# Create, Compile and run csharp Project
- **Create Dotnet project**
     - dotnet new console -n MyApp
- Compile
    - `csc Program.cs` ---> convert the csharp into the FileName.exe file
    - `Program.exe` ---> This command help to run the code.
- Run
    - `dotnet run Program.cs` ---> This command help to compile and run both the code at a time.

## Entry point of csharp code
- program.cs file is the entry point in the csharp code which is present in the System namespace(package)
- all variable and method are by default private in csharp

- **every class is by default `internal` in c#** ---> means it can essible within the same project
- Entry point line can be allow only
```
static void Main()
static int Main()
static void Main(string[] args)
static int Main(string[] args)
```
##
- Must be static ‚Üí So the runtime can call it without creating an object.
- Must be Main ‚Üí It‚Äôs the predefined entry point recognized by the CLR.
- Return type: void or int ‚Üí Void ends execution cleanly, int returns status code to the OS.

## Exicution of program in c#
```
     C# Code (.cs)
         ‚Üì
     C# Compiler (csc / Roslyn)
         ‚Üì
     IL Code (.exe / .dll)
         ‚Üì
     CLR (Common Language Runtime)
         ‚Üì
     Machine Code ‚Üí Program Runs
```

## Intermediate Language (IL)
- Platform-independent code
- Generated by the C# compiler(csc or Rosyln)
- also called MSIL / CIL

## Three area in the csharp
1. Heap area
2. stack area
3. static area

- Static methods and members are associated with the class itself, initialized once when the type(blue print like class and struct) is loaded, and do not require object creation.


## Access Modifier
- public             ‚Üí Accessible everywhere
- private            ‚Üí Same class only
- protected          ‚Üí Same class + derived class (any - project)
- internal           ‚Üí Same project only
- protected internal ‚Üí Same project OR derived class (any project)
- private protected  ‚Üí Same class + derived class (same project only)

## Default Access Modifiers in C#
| Member Type        | Location       | Default Access Modifier |
|--------------------|----------------|--------------------------|
| Class              | Top-level      | internal                 |
| Class              | Nested         | private                  |
| Method             | Inside class   | private                  |
| Variable / Field   | Inside class   | private                  |
| Constructor        | Inside class   | private                  |



## memory area in the csharp || memory management in csharp
| Memory Area     | Managed by GC | Lifetime          |
|-----------------|---------------|-------------------|
| Stack           | ‚ùå No          | Method scope      |
| Heap            | ‚úÖ Yes         | Until unreachable |
| Static          | ‚ùå No          | App lifetime      |
| Code / Metadata | ‚ùå No          | App lifetime      |
| Unmanaged       | ‚ùå No          | Manual cleanup    |

## java vs csharp
| Feature                | Java                                                                 | C#                                                                 |
|-------------------------|----------------------------------------------------------------------|--------------------------------------------------------------------|
| **Developer / Origin**  | Sun Microsystems (now Oracle)                                        | Microsoft (led by Anders Hejlsberg)                                |
| **Runtime Environment** | JVM (Java Virtual Machine)                                           | CLR (Common Language Runtime)                                      |
| **Platform**            | Platform-independent (runs anywhere with JVM)                        | Primarily Windows/.NET ecosystem, but now cross-platform via .NET Core |
| **Compilation**         | Compiles to bytecode, executed by JVM                                | Compiles to Intermediate Language (IL), executed by CLR            |
| **Memory Management**   | Automatic Garbage Collection                                         | Automatic Garbage Collection                                       |
| **Operator Overloading**| Not supported                                                        | Supported                                                          |
| **Pointers**            | Not supported                                                        | Supported in unsafe context                                        |
| **Generics**            | Type erasure (no runtime type info)                                  | Reified generics (runtime type info preserved)                     |
| **Checked Exceptions**  | Supported (forces handling)                                          | Not supported                                                      |
| **Multiple Inheritance**| Not supported (uses interfaces)                                      | Not supported (uses interfaces)                                    |
| **Properties**          | Implemented via getter/setter methods                                | Built-in property syntax                                           |
| **Enums**               | More limited, treated as special classes                             | Richer, more powerful enums                                        |
| **Delegates / Events**  | Uses interfaces and anonymous classes                                | First-class support via delegates and events                       |
| **Libraries / APIs**    | Rich standard library, community-driven                              | Rich standard library, tightly integrated with Windows/.NET         |
| **Cross-Platform**      | Strong portability across OS                                         | Initially Windows-focused, now cross-platform via .NET Core         |
| **Use Cases**           | Enterprise apps, Android development, cross-platform systems         | Enterprise apps, Windows apps, game dev (Unity), cloud apps         |
---

## Command line argumnet in csharp
```  
     int month = Convert.ToInt32(args[0]);
     int day = Convert.ToInt32(args[1]);
```
**To pass input values**
- dotnet run 3 25
- FileName.exe 3 25

## String
1. String constant pool: special area inside the heap memory Created using string literals can't exccessible so it more secure.
- string constant pool me object banta hai when we string literal
- static object ke pass 1 object banta hai to agle object ko kaise point karega
- we can't excess the constant pool area
2. what is exist in the csharp(c#)
- ‚ùå StringBuffer does NOT exist in C#
- ‚úÖ StringBuilder EXISTS in C#



- Is operator in the csharp use to check wheather the object of which class
- Every class have constructor
- fully cally class name when we print the refernce and refernce address print in hexa code we cant decode
- either we can use the constructor or we can use the getter and setter
- return string ? ---> means return any types of values
- `Diamond problem`: child does not know which path i have to follow(parent1, parent2) to go to super most class (like system and object);
- diamond problem can be solve using interface instead of multiple inheritance because we can override the method in interface.
- static can be overload not override



# üìò UML Class Diagram Notes (Aggregation)

## UML Visibility Symbols (C#)
- `+` : **public**
- `-` : **private**
- `#` : **protected**
- `~` : **internal**
- `<>` : **aggregation**
```
- class diagram 
- sequence diagram
- object modelling
```
---
## Access Modifier allow for the main class in c#
- In C#, there are two class access modifiers: `public` and `internal`.
- In C#, a nested class can have five access modifiers: `public`, `private`, `protected`, `internal`, and `protected internal`.
- `readonly: ` You need to return multiple results || To improve code safety and maintainability.

## out keyword
- use to pass the value of variable from method to caller.
- Return multiple values.
- Send data from method to caller
- Avoid creating wrapper objects or classes
- Indicate output-only parameters
- Improve performance (no extra object creation)

## OOPS 
- (Object-Oriented Programming System) is a programming approach based on objects that combine data and methods to model real-world entities.

## Encapsulation (Data Hiding)
- Wrapping data + methods into one unit (class)
- Restrict direct access using private
- Access data via properties (method like getter and setter using public access modifier)

## Inheritance (Code Reusability)
- One class acquires properties of another class
- `: symbol used`
- ex: Animal --> Dog

## Polymorphism (Many Forms)
- Same method name
- Different behavior

- **Types**:
     - Compile-time (Method Overloading)    
          - `within same class`
          - decision happen at compile time
     - Runtime (Method Overriding) 
          - `Overriding` means a child class changes the behavior of a method defined in the parent class using the same method signature.
          - `Method Hiding` means a child class creates a new method with the same name as the parent method, hiding the parent method.
               `ex: ` 
               `
                    public new void sameMethodName() {
                         Console.WriteLine("Child Show Method");
                    }
               `
          - `within different class`
          - decision happen at run time

## Constructor
- A constructor is a special method
- Same name as class
- Automatically called when object is created
- Used to initialize data

üîπ Types
- Default constructor
- Parameterized constructor
- `Static constructor`
     - Runs only once
     - Used to initialize static data
     - Cannot have parameters
- `copy constructor`: Copy Constructor is a constructor that creates a new object by copying the values of another existing object of the same class.

- `this` is used to refer to the current instance of the same class.
- `base` is used to refer to the instance of immediate parent class.
- `base()` - use to call the parent class constructor.

- `const` is used to declare constants at compile-time.
     - `ex:` const int MaxValue = 100;

- `readonly` is used to declare variables that can be assigned only once, either: at declaration, or inside the constructor.

## `Constructor chaning`
     Constructor chaining is a mechanism where one constructor calls another constructor of the same class or the base (parent) class to avoid code duplication and ensure proper initialization of objects.


##
`git fetch`: Used to get the latest changes from the remote repository without affecting your current branch or code.

`git pull`: Used to get the latest changes from the remote repository and immediately merge them into your current branch.

##
`A namespace is a logical container that organizes code and prevents naming collisions.`

## 
abstract method ---> Non cocreate method by default public + abstract
non abstract method---> Concrete method

## Loose coupling by using Interface
`ILoan loan = new HomeLoan();` so that i dont have to change the whole object;

## version 2 v-2
- IWheather api = new Google();
- IWheather api = new Microsoft();
- IWheather api = new Amazon();
- IWheather api = new Tesla();

## Next versions losse coupling
- IWheather api;
- api = new Google();
- api = new Microsoft();
- api = new Amazon();
- api = new Tesla();

## encapsulation
- Use the user data and store them inside a class which is encapsulated.


## SOLID Principle
- `S ‚Äì Single Responsibility Principle (SRP)` ‚Üí One class, one job (make every class and interface for a single purpose like for IUser, IPay, ICart);
- `O ‚Äì Open/Closed Principle (OCP)` ‚Üí Extend, don‚Äôt modify (previous things dont change)
- `L ‚Äì Liskov Substitution Principle (LSP)` ‚Üí Child behaves like parent
- `I ‚Äì Interface Segregation Principle (ISP)` ‚Üí Small, focused interfaces
- `D ‚Äì Dependency Inversion Principle (DIP)` ‚Üí Depend on interfaces, not classes (like constructor dependency injection)
---

## 
- The Main method cannot be overridden in C# because it is static.
- Static methods do not support polymorphism, so override is not allowed.
- Writing another Main method in a child class results in method hiding, not overriding.
- When multiple Main methods exist, only one is chosen as the program entry point based on project settings.
- Therefore, Main does not participate in inheritance or runtime polymorphism in C#.
- `Var data types:` all rounder data types in csharp
## 
`TryParse:-` is used to safely convert a string into another data type (like int, double, DateTime, etc.) without throwing an exception if the conversion fails.

##
**Upcasting** is an Object-Oriented Programming concept where a child class object is referenced using a parent class type.
```
// Upcasting
Animal animal = new Dog();
animal.Eat();    // Parent method
animal.Sound();  // Child method (runtime polymorphism)
// animal.Bark(); ‚ùå Not accessible
```
**Downcasting** is an Object-Oriented Programming concept where a parent class reference is converted back into a child class type.
```
// Upcasting
Animal animal = new Dog();    
// Downcasting (explicit)
Dog dog = (Dog)animal;   
dog.Bark();  // Child method
```

## Convertion of data types
1. **Implicite** *safe*
> byte ‚Üí short ‚Üí int ‚Üí long ‚Üí float ‚Üí double

     ```
     int a = 10;
     double b = a;   // int ‚Üí double (implicit)
     Console.WriteLine(b);
     ```
2. **Explicite** *unsafe*
> double ‚Üí float ‚Üí long ‚Üí int

     ```
     double a = 10.75;
     int b = (int)a;   // double ‚Üí int (explicit)
     Console.WriteLine(b);  // Output: 10
     ```

# Boxing and Unboxing
## Boxing (C#)
Boxing is the process of converting a value type (like int, float, struct) into an object type.
```
int a = 10;
object obj = a;   // boxing
```
## Unboxing (C#)
Unboxing is the process of converting a boxed object back into its original value type.
It requires explicit type casting.
```
object obj = 20;  
int b = (int)obj;   // unboxing
```
## üîç Comparison Table

| Feature         | var           | dynamic        | object             |
|-----------------|---------------|----------------|--------------------|
| Type Binding    | Compile-time  | Runtime        | Compile-time       |
| Type Safety     | High          | Low            | Medium             |
| Casting Needed  | No            | No             | Yes                |
| Performance     | Fast          | Slower         | Slower (boxing)    |
| Change Type     | ‚ùå No         | ‚úÖ Yes         | ‚úÖ Yes             |
---
## üîπ Nullable Type (C#)

**Definition:**  
A nullable type allows a **value type** (like `int`, `bool`, `double`) to store **null** values.  
It is denoted using the `?` symbol.

**Example:**
```csharp
int? age = null;
age = 25;
```
# int.Parse vs Convert.ToInt32
| Feature / Method | `int.Parse()` | `Convert.ToInt32()` | `Convert.ToInt64()` | `long.Parse()` | `int.TryParse()` |
|----------------|---------------|---------------------|---------------------|---------------|------------------|
| Target type | `int` (32-bit) | `int` (32-bit) | `long` (64-bit) | `long` (64-bit) | `int` (32-bit) |
| Accepts `null` | ‚ùå Exception | ‚úÖ Returns `0` | ‚úÖ Returns `0` | ‚ùå Exception | ‚úÖ Returns `false` |
| Input types | `string` only | Many types | Many types | `string` only | `string` only |
| Throws exception | ‚úÖ Yes | ‚úÖ Yes | ‚úÖ Yes | ‚úÖ Yes | ‚ùå No |
| Return on failure | Exception | Exception | Exception | Exception | `false` |
| Range | ‚àí2.1B to +2.1B | ‚àí2.1B to +2.1B | ‚àí9.2E18 to +9.2E18 | ‚àí9.2E18 to +9.2E18 | ‚àí2.1B to +2.1B |
| Safer to use | ‚ùå | ‚úÖ | ‚úÖ | ‚ùå | ‚úÖ‚úÖ Best |
---

## üîπ Extension Method (C#)

### Definition:
An extension method allows you to add new methods to an existing type without modifying its source code or using inheritance.

### Rules:
- Must be defined in a **static class**
- Method must be **static**
- Uses the **this** keyword before the first parameter
---
## üîπ Static Class (C#)

### Definition:
A static class is a class that **cannot be instantiated** and is used to contain **only static members** such as methods, variables, and properties.

### Key Points:
- Cannot create objects of a static class
- Contains only static members
- Cannot be inherited
- Used for utility or helper classes

### Example:
```csharp
static class MathUtility
{
    public static int Add(int a, int b)
    {
        return a + b;
    }
}

// Usage
int result = MathUtility.Add(10, 20);
```
---
## üîπ Object Initializer (C#)

### Definition:
An object initializer allows you to **assign values to an object‚Äôs properties or fields at the time of object creation**, without calling a constructor explicitly.

### Key Points:
- Improves code readability
- No need to write multiple assignment statements
- Uses curly braces `{ }`
- Calls the default constructor automatically

### Example:
```csharp
class Student
{
    public int Id { get; set; }
    public string Name { get; set; }
}

Student s = new Student
{
    Id = 1,
    Name = "Rahul"
};
```
---
## Anominous types: 
- An anonymous type is a class created on the fly without a named class definition, mainly used to store a set of read-only properties in a single object.
---
## Partial types:
- A partial type allows a class, struct, or interface to be split across multiple files. At compile time, all parts are combined into a single type.
---
## Valued-Types:
- Value types store the actual data directly in memory. Each variable has its own copy of the data.

## Refernce-Types
- Reference types store a reference (address) to the actual data in memory. Multiple variables can refer to the same object.

## üîπ Structure (struct) in C#

### Definition:
A structure is a **value type** used to group related variables of different data types under a single name.

### Key Points:
- Value type
- Stored on stack
- Does not support inheritance
- Can have methods, constructors, and properties

### Example:
```csharp
struct Student
{
    public int Id;
    public string Name;

    public void Display()
    {
        Console.WriteLine(Id + " " + Name);
    }
}
```
---
## üîπ Enum (Enumeration) in C#

### Definition:
An enum is a **value type** used to define a set of **named constant values**.

### Key Points:
- Improves code readability  
- Underlying type is `int` by default  
- Values are constant  

### Example:
```csharp
enum Days
{
    Sunday,
    Monday,
    Tuesday,
    Wednesday
}
```
---
## üîπ is Operator (C#)

### Definition:
The `is` operator is used to **check whether an object is of a specific type**.  
It returns **true or false**.

### Explanation:
- Performs type checking
- Safe and fast
- Commonly used in conditional statements

### Example:
```csharp
object obj = "Hello";

if (obj is string)
{
    Console.WriteLine("obj is a string");
}
```
---
## üîπ as Operator (C#)

### Definition:
The `as` operator is used for **safe type casting**.  
If the conversion fails, it returns **null** instead of throwing an exception.

### Explanation:
- Works only with **reference types** and **nullable types**
- Does **not throw an exception** on failure
- Requires **null checking** after use

### Example:
```csharp
object obj = "Hello";

string str = obj as string;

if (str != null)
{
    Console.WriteLine(str.ToUpper());
}
```
---
## Arcitecture use in c# coding
1. Monolithic layer
2. Model layer
3. Utlity layer (service layer) (bussiness layer)
4. data base layer
5. Controller (use in collection)

# üåê HTTP Status Codes ‚Äì Tech Industry Cheat Sheet

## üîµ 1xx ‚Äì Informational (Rare in daily use)
Used internally by browsers/servers.

- **100** ‚Äì Continue  
- **101** ‚Äì Switching Protocols  
---

## üü¢ 2xx ‚Äì Success (Most important)
Used when request is **successful**.

| Code | Meaning | Industry Use |
|----|--------|--------------|
| **200** | OK | Successful GET / PUT |
| **201** | Created | Resource created (POST) |
| **202** | Accepted | Async processing |
| **204** | No Content | Success, no response body |
---

## üü° 3xx ‚Äì Redirection (Web-heavy)
Used mainly in **browsers & SEO**.

| Code | Meaning | Use |
|----|--------|-----|
| **301** | Moved Permanently | SEO redirect |
| **302** | Found | Temporary redirect |
| **304** | Not Modified | Caching |
| **307** | Temporary Redirect | API-safe redirect |
| **308** | Permanent Redirect | API permanent |
---

## üî¥ 4xx ‚Äì Client Errors (Very common)
Client sent **bad request**.

| Code | Meaning | Industry Scenario |
|----|--------|-------------------|
| **400** | Bad Request | Invalid JSON / params |
| **401** | Unauthorized | Token missing |
| **403** | Forbidden | No permission |
| **404** | Not Found | API / page missing |
| **405** | Method Not Allowed | Wrong HTTP verb |
| **409** | Conflict | Duplicate data |
| **415** | Unsupported Media Type | Wrong Content-Type |
| **422** | Unprocessable Entity | Validation failed |
| **429** | Too Many Requests | Rate limit |
---

## ‚ö´ 5xx ‚Äì Server Errors (Critical)
Problem on **server side**.

| Code | Meaning | Industry Meaning |
|----|--------|------------------|
| **500** | Internal Server Error | Code crash |
| **502** | Bad Gateway | Downstream service error |
| **503** | Service Unavailable | Server overloaded |
| **504** | Gateway Timeout | No response from service |
---

# Composition and Aggregation (OOP)

## 1Ô∏è‚É£ Composition

### Definition
Composition is a **strong has-a relationship** in which the child object **cannot exist without** the parent object.  
When the parent is destroyed, the child is also destroyed.

### Example (C#)
```csharp
class Engine
{
    public void Start()
    {
        Console.WriteLine("Engine started");
    }
}

class Car
{
    private Engine engine;

    public Car()
    {
        engine = new Engine(); // Engine created inside Car
    }

    public void Drive()
    {
        engine.Start();
        Console.WriteLine("Car is moving");
    }
}
```

## 2Ô∏è‚É£ Aggregation

### Definition
Aggregation is a **weak has-a relationship** where the child object **can exist independently** of the parent object.

### Example (C#)
```csharp
class Employee
{
    public string Name { get; set; }
}

class Department
{
    public Employee employee;

    public Department(Employee emp)
    {
        employee = emp; // Employee exists independently
    }
}
```

# Asymptotic Notation

Asymptotic notation is used to describe the **time and space complexity** of an algorithm as the input size (**n**) grows very large. It helps compare algorithm efficiency independent of hardware or programming language.

---

## üîπ Types of Asymptotic Notations

### 1Ô∏è‚É£ Big-O Notation (O)

**Definition:**  
Represents the **worst-case** time or space complexity.

**Example:**
```csharp
for(int i = 0; i < n; i++)
{
    Console.WriteLine(i);
}
```

## 2Ô∏è‚É£ Big-Œ© Notation (Omega Œ©)

### Definition
Represents the **best-case** time complexity.

### Example
```csharp
if(arr[0] == key)
{
    return true;
}
```

## 3Ô∏è‚É£ Big-Œò Notation (Theta Œò)

### Definition
Represents the **average or exact bound** (both upper and lower).

### Example
```csharp
for(int i = 0; i < n; i++)
{
    Console.WriteLine(i);
}
```
## üîπ Common Time Complexities
| Notation | Name |
|--------|------|
| O(1) | Constant |
| O(log n) | Logarithmic |
| O(n) | Linear |
| O(n log n) | Linearithmic |
| O(n¬≤) | Quadratic |
| O(2‚Åø) | Exponential |
---

#  Annotation vs Reflection
| Feature | Annotation (Attribute) | Reflection |
|-------|------------------------|------------|
| What it does | Adds metadata | Reads metadata |
| Time | Compile time | Runtime |
| Purpose | Describe code | Inspect / use description |

#
