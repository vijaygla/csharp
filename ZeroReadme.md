# Compile and run csharp code
- Compile
    - `csc FileName.cs` ---> convert the csharp into the FileName.exe file
    - `FileName.exe` ---> This command help to run the code.
- Run
    - `dotnet run FileName.cs` ---> This command help to compile and run both the code at a time.

## Entry point of csharp code
- program.cs file is the entry point in the csharp code which is present in the System namespace(package)
- all variable and method are by default private in csharp

- **every class is by default `internal` in c#** ---> means it can essible within the same project
- Entry point line can be allow only
```
static void Main()
static int Main()
static void Main(string[] args)
static int Main(string[] args)
```
###
- Must be static â†’ So the runtime can call it without creating an object.
- Must be Main â†’ Itâ€™s the predefined entry point recognized by the CLR.
- Return type: void or int â†’ Void ends execution cleanly, int returns status code to the OS.

## Exicution of program in c#
```
     C# Code (.cs)
         â†“
     C# Compiler (csc / Roslyn)
         â†“
     IL Code (.exe / .dll)
         â†“
     CLR (Common Language Runtime)
         â†“
     Machine Code â†’ Program Runs
```


## Intermediate Language (IL)
- Platform-independent code
- Generated by the C# compiler(csc or Rosyln)
- also called MSIL / CIL

## Three area in the csharp
1. Heap area
2. stack area
3. static area

- Static methods and members are associated with the class itself, initialized once when the type(blue print like class and struct) is loaded, and do not require object creation.


## Access Modifier
- public             â†’ Accessible everywhere
- private            â†’ Same class only
- protected          â†’ Same class + derived class (any - project)
- internal           â†’ Same project only
- protected internal â†’ Same project OR derived class (any project)
- private protected  â†’ Same class + derived class (same project only)


## memory area in the csharp || memory management in csharp
| Memory Area     | Managed by GC | Lifetime          |
|-----------------|---------------|-------------------|
| Stack           | âŒ No          | Method scope      |
| Heap            | âœ… Yes         | Until unreachable |
| Static          | âŒ No          | App lifetime      |
| Code / Metadata | âŒ No          | App lifetime      |
| Unmanaged       | âŒ No          | Manual cleanup    |

## java vs csharp
| Feature                | Java                                                                 | C#                                                                 |
|-------------------------|----------------------------------------------------------------------|--------------------------------------------------------------------|
| **Developer / Origin**  | Sun Microsystems (now Oracle)                                        | Microsoft (led by Anders Hejlsberg)                                |
| **Runtime Environment** | JVM (Java Virtual Machine)                                           | CLR (Common Language Runtime)                                      |
| **Platform**            | Platform-independent (runs anywhere with JVM)                        | Primarily Windows/.NET ecosystem, but now cross-platform via .NET Core |
| **Compilation**         | Compiles to bytecode, executed by JVM                                | Compiles to Intermediate Language (IL), executed by CLR            |
| **Memory Management**   | Automatic Garbage Collection                                         | Automatic Garbage Collection                                       |
| **Operator Overloading**| Not supported                                                        | Supported                                                          |
| **Pointers**            | Not supported                                                        | Supported in unsafe context                                        |
| **Generics**            | Type erasure (no runtime type info)                                  | Reified generics (runtime type info preserved)                     |
| **Checked Exceptions**  | Supported (forces handling)                                          | Not supported                                                      |
| **Multiple Inheritance**| Not supported (uses interfaces)                                      | Not supported (uses interfaces)                                    |
| **Properties**          | Implemented via getter/setter methods                                | Built-in property syntax                                           |
| **Enums**               | More limited, treated as special classes                             | Richer, more powerful enums                                        |
| **Delegates / Events**  | Uses interfaces and anonymous classes                                | First-class support via delegates and events                       |
| **Libraries / APIs**    | Rich standard library, community-driven                              | Rich standard library, tightly integrated with Windows/.NET         |
| **Cross-Platform**      | Strong portability across OS                                         | Initially Windows-focused, now cross-platform via .NET Core         |
| **Use Cases**           | Enterprise apps, Android development, cross-platform systems         | Enterprise apps, Windows apps, game dev (Unity), cloud apps         |
---

## Command line argumnet in csharp
```  
     int month = Convert.ToInt32(args[0]);
     int day = Convert.ToInt32(args[1]);
```
**To pass input values**
- dotnet run 3 25
- FileName.exe 3 25

## String
1. String constant pool: special area inside the heap memory Created using string literals can't exccessible so it more secure.
- string constant pool me object banta hai when we string literal
- static object ke pass 1 object banta hai to agle object ko kaise point karega
- we can't excess the constant pool area
2. what is exist in the csharp(c#)
- âŒ StringBuffer does NOT exist in C#
- âœ… StringBuilder EXISTS in C#



- Is operator in the csharp use to check wheather the object of which class
- Every class have constructor
- fully cally class name when we print the refernce and refernce address print in hexa code we cant decode
- either we can use the constructor or we can use the getter and setter
- return string ? ---> means return any types of values
- `Diamond problem`: child does not know which path i have to follow(parent1, parent2) to go to super most class (like system and object);
- diamond problem can be solve using interface instead of multiple inheritance because we can override the method in interface.
- static can be overload not override



# ðŸ“˜ UML Class Diagram Notes (Aggregation)

## UML Visibility Symbols (C#)
- `+` : **public**
- `-` : **private**
- `#` : **protected**
- `~` : **internal**
- `<>` : **aggregation**

---

## ðŸ”¹ What is Aggregation?
- Aggregation is a **"Has-A" relationship** between classes.  
- It represents a **whole-part relationship** where the part can exist independently of the whole.  
- Shown in UML with a **hollow diamond (<>--).**

---
- method having the smame signature in the overiding

- **Method hiding**: when we override the static method 
- Yes, static methods can be overloaded in C# because overloading is resolved at compile time, but they cannot be overridden.
- use virtual for the base method and use the override in case of override method
- interfcae have non concreate method
- abstract class have both concreate as well as non concrete method
- interface does not have any constructor.

## Access Modifier allow for the main class in c#
- In C#, there are two class access modifiers: `public` and `internal`.
- In C#, a nested class can have five access modifiers: `public`, `private`, `protected`, `internal`, and `protected internal`.
- `readonly: ` You need to return multiple results || To improve code safety and maintainability.

### out keyword
- use to pass the value of variable from method to caller.
- Return multiple values.
- Send data from method to caller
- Avoid creating wrapper objects or classes
- Indicate output-only parameters
- Improve performance (no extra object creation)

### OOPS 
- (Object-Oriented Programming System) is a programming approach based on objects that combine data and methods to model real-world entities.

### Encapsulation (Data Hiding)
- Wrapping data + methods into one unit (class)
- Restrict direct access using private
- Access data via properties (method like getter and setter using public access modifier)

### Inheritance (Code Reusability)
- One class acquires properties of another class
- `: symbol used`
- ex: Animal --> Dog

### Polymorphism (Many Forms)
- Same method name
- Different behavior

- **Types**:
     - Compile-time (Method Overloading)    
          - `within same class`
          - decision happen at compile time
     - Runtime (Method Overriding) 
          - `Overriding` means a child class changes the behavior of a method defined in the parent class using the same method signature.
          - `Method Hiding` means a child class creates a new method with the same name as the parent method, hiding the parent method.
               `ex: ` 
               `
                    public new void sameMethodName() {
                         Console.WriteLine("Child Show Method");
                    }
               `
          - `within different class`
          - decision happen at run time

### Constructor
- A constructor is a special method
- Same name as class
- Automatically called when object is created
- Used to initialize data

ðŸ”¹ Types
- Default constructor
- Parameterized constructor
- `Static constructor`
     - Runs only once
     - Used to initialize static data
     - Cannot have parameters
- `copy constructor`: Copy Constructor is a constructor that creates a new object by copying the values of another existing object of the same class.

- `this` is used to refer to the current instance of the same class.
- `base` is used to refer to the instance of immediate parent class.
- `base()` - use to call the parent class constructor.

- `const` is used to declare constants at compile-time.
     - `ex:` const int MaxValue = 100;

- `readonly` is used to declare variables that can be assigned only once, either: at declaration, or inside the constructor.

### `Constructor chaning`
     Constructor chaining is a mechanism where one constructor calls another constructor of the same class or the base (parent) class to avoid code duplication and ensure proper initialization of objects.


###
`git fetch`: Used to get the latest changes from the remote repository without affecting your current branch or code.

`git pull`: Used to get the latest changes from the remote repository and immediately merge them into your current branch.

###
`A namespace is a logical container that organizes code and prevents naming collisions.`



### 
abstract method ---> Non cocreate method by default public + abstract
non abstract method---> Concrete method

### Loose coupling by using Interface
`ILoan loan = new HomeLoan();` so that i dont have to change the whole object;

### version 2 v-2
- IWheather api = new Google();
- IWheather api = new Microsoft();
- IWheather api = new Amazon();
- IWheather api = new Tesla();

### Next versions losse coupling
- IWheather api;
- api = new Google();
- api = new Microsoft();
- api = new Amazon();
- api = new Tesla();

### encapsulation
- Use the user data and store them inside a class which is encapsulated.


### SOLID Principle
- `S â€“ Single Responsibility Principle (SRP)` â†’ One class, one job (make every class and interface for a single purpose like for IUser, IPay, ICart);
- `O â€“ Open/Closed Principle (OCP)` â†’ Extend, donâ€™t modify (previous things dont change)
- `L â€“ Liskov Substitution Principle (LSP)` â†’ Child behaves like parent
- `I â€“ Interface Segregation Principle (ISP)` â†’ Small, focused interfaces
- `D â€“ Dependency Inversion Principle (DIP)` â†’ Depend on interfaces, not classes (like constructor dependency injection)
---

### 
- The Main method cannot be overridden in C# because it is static.
- Static methods do not support polymorphism, so override is not allowed.
- Writing another Main method in a child class results in method hiding, not overriding.
- When multiple Main methods exist, only one is chosen as the program entry point based on project settings.
- Therefore, Main does not participate in inheritance or runtime polymorphism in C#.

